import heapq

# Goal state
GOAL_STATE = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 0]
]

# Directions: (dx, dy) - up, down, left, right
MOVES = [(-1, 0), (1, 0), (0, -1), (0, 1)]


class PuzzleState:
    def __init__(self, board, parent=None, move=0, cost=0):
        self.board = board
        self.parent = parent
        self.move = move
        self.cost = cost
        self.zero_pos = self.find_zero()
        self.key = self.serialize()
        self.f = self.cost + self.heuristic()

    def find_zero(self):
        for i in range(3):
            for j in range(3):
                if self.board[i][j] == 0:
                    return i, j

    def serialize(self):
        return str(self.board)

    def heuristic(self):
        # Manhattan distance
        distance = 0
        for i in range(3):
            for j in range(3):
                val = self.board[i][j]
                if val != 0:
                    goal_x = (val - 1) // 3
                    goal_y = (val - 1) % 3
                    distance += abs(i - goal_x) + abs(j - goal_y)
        return distance

    def is_goal(self):
        return self.board == GOAL_STATE

    def generate_successors(self):
        successors = []
        x, y = self.zero_pos
        for dx, dy in MOVES:
            new_x, new_y = x + dx, y + dy
            if 0 <= new_x < 3 and 0 <= new_y < 3:
                new_board = [row[:] for row in self.board]
                # Swap zero with neighbor
                new_board[x][y], new_board[new_x][new_y] = new_board[new_x][new_y], new_board[x][y]
                successors.append(PuzzleState(new_board, parent=self, move=self.move + 1, cost=self.cost + 1))
        return successors

    def get_path(self):
        path = []
        state = self
        while state:
            path.append(state.board)
            state = state.parent
        return path[::-1]  # Reverse the path


def a_star_search(start_board):
    start_state = PuzzleState(start_board)
    frontier = []
    heapq.heappush(frontier, (start_state.f, start_state))
    explored = set()

    while frontier:
        _, current = heapq.heappop(frontier)

        if current.is_goal():
            return current.get_path()

        explored.add(current.key)

        for neighbor in current.generate_successors():
            if neighbor.key not in explored:
                heapq.heappush(frontier, (neighbor.f, neighbor))

    return None


def print_board(board):
    for row in board:
        print(" ".join(str(cell) if cell != 0 else ' ' for cell in row))
    print()


if __name__ == "__main__":
    # Example start state
    start = [
        [1, 2, 3],
        [4, 0, 6],
        [7, 5, 8]
    ]

    print("Initial State:")
    print_board(start)

    path = a_star_search(start)

    if path:
        print("Solution found in", len(path) - 1, "moves:\n")
        for step in path:
            print_board(step)
    else:
        print("No solution found.")
